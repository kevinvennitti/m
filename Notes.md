# Définir

- Quel(s) langage(s) / quelle(s) typologie(s) de langages ?
  - Structurel (HTML, CSS) ?
  - Dynamique (PHP, Javascript) ?
  - Orienté objet (Classes, Objets) ?


# Faire

- Étudier les systèmes existants et expliciter « rapidement » les typologies : disposition spatiale (flow-based programming), disposition linéaire (Blockly)
- Étudier la structure d’un code textuel (linéarité haut-bas, types de contrôles (extraire aussi des choix de l’interface de blockly) (conditions, actions, événements)
- Trouver d’autres types d’interaction (par la contrainte ?) :
  - Ne pas avoir de HUD (cf. Ink sketchpad : dessiner la lettre de l’outil à utiliser)
  - Écrire sur papier, scanner, reconnaître, convertir et exécuter comme code
  - Visualiser du code textuel en programmation visuelle, interagir avec la programmation visuelle pour revenir au code textuel (développement en parallèle, deux vues)
  - Langage naturel (trop textuel pour le thème du mémoire ?)
  - Principe du « Finder » où on clique dans l’UI là où on veut interagir, puis on tape textuellement le terme/l’action/l’objectif recherché puis on inscrit le « module » (quid de l’autocomplétion ?)
  - Gestuelles (faire une boucle sur une ligne de code crée une boucle parcourant une variable, etc)
  - Utiliser la reconnaissance vocale de Google pour reconnaître les expressions et les inscrire (Si la variable est égale à ça et la variable est égale à ça, alors)
- Faire des schémas à deux axes, montrant où se place le langage textuel et la programmation visuelle (limites de chaque modèle dans le temps, dans la complexité, dans les besoins, dans l’expérience (1 an de code, 2 ans de code, 5 ans de code)


# Écrire

- Prélude : présenter mon profil designer + développeur, puis introduire l’énonciation 
- …
  - [Quels modèles mentaux ?](blog.interfacevision.com/info/vpls-and-mental-models/) Il n’y a pas qu’un seul modèle mental : développer, lister
- Les limites de la programmation visuelle
  - La possibilité de faire une erreur : la programmation visuelle est également perçue pour être infaillible, tout du moins très stable, sur l’écriture de la syntaxe, évitant ainsi toute erreur de programme.
  - ➜ …mais ?